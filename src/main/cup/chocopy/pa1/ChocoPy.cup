import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        int last_index = nodes.size() - 1;
        Node last = nodes.get(last_index);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }

    IfStmt insertElse(IfStmt elif, List<Stmt> elseBody){
        if (elif.elseBody.isEmpty()){
            Location left = new ComplexSymbolFactory.Location(elif.getLocation()[0], elif.getLocation()[1]);
            Location right = getRight(elseBody);
            return new IfStmt(left, right, elif.condition, elif.thenBody, elseBody);
        }
        IfStmt elifInternal = (IfStmt) elif.elseBody.get(0);
        IfStmt elifNested = insertElse(elifInternal, elseBody);
        Location newLeft = new ComplexSymbolFactory.Location(elif.getLocation()[0], elif.getLocation()[1]);
        Location newRight = getRight(elseBody);
        return new IfStmt(newLeft, newRight, elif.condition, elif.thenBody, single(elifNested));
    };

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
terminal NEWLINE;
terminal INDENT;
terminal DEDENT;

/* Errors */
/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;   
terminal INTEGER_OVERFLOW_LEXICAL_ERROR;
terminal INDENTATION_ERROR;

/* Keywords. */
terminal String FALSE; 
terminal String NONE;
terminal String TRUE;
terminal String AND;
terminal String AS;
terminal String ASSERT;
terminal String ASYNC;
terminal String AWAIT;
terminal String BREAK;
terminal String CLASS;
terminal String CONTINUE;
terminal String DEF;
terminal String DEL;
terminal String ELIF;
terminal String ELSE;
terminal String EXCEPT;
terminal String FINALLY;
terminal String FOR;
terminal String FROM;
terminal String GLOBAL;
terminal String IF;
terminal String IMPORT;
terminal String IN;
terminal String IS;
terminal String LAMBDA;
terminal String NONLOCAL;
terminal String NOT;
terminal String OR;
terminal String PASS;
terminal String RAISE;
terminal String RETURN;
terminal String TRY;
terminal String WHILE;
terminal String WITH;
terminal String YIELD;

/* Literals. */
terminal Integer INTEGER_LITERAL; 
terminal String IDSTRING;
terminal String STRING;

/* Operators. */
terminal String PLUS; 
terminal String MINUS;
terminal String TIMES;
terminal String INTEGER_DIVISION;
terminal String MOD;
terminal String LESS_THAN;
terminal String GREATER_THAN;
terminal String LESS_OR_EQUAL_THAN;
terminal String GREATER_OR_EQUAL_THAN;
terminal String EQUALS;
terminal String NOT_EQUALS;
terminal String ASSIGN;
terminal String LEFT_PARENTHESIS;
terminal String RIGHT_PARENTHESIS;
terminal String LEFT_BRACKET;
terminal String RIGHT_BRACKET;
terminal String COMMA;
terminal String COLON;
terminal String DOT;
terminal String RIGHT_ARROW;

/* Identifiers. */
terminal String IDENTIFIER;

/* Auxiliar terminals */
//terminal EOF;


/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program           program;
non terminal List<Declaration> class_body;
non terminal List<Stmt>        block;
non terminal Stmt              simple_stmt, stmt;
non terminal Expr              target;
non terminal Expr              expr;

non terminal MemberExpr        member_expr;
non terminal IndexExpr         index_expr;

non terminal Literal           literal;
non terminal String            bin_op;
non terminal TypeAnnotation    type;
non terminal TypedVar          typed_var;
non terminal VarDef            var_def;
non terminal ClassDef          class_def;
non terminal FuncDef           func_def;
non terminal GlobalDecl        global_decl;
non terminal NonLocalDecl      nonlocal_decl;


/* Auxiliares */
non terminal Expr              cexpr;
non terminal List<Expr>        expr_params;
non terminal List<Expr>        optional_exprs;

non terminal List<Declaration> optional_program_declarations;
non terminal List<Declaration> required_class_body_definitions;
non terminal List<Declaration> optional_func_body_declarations;
non terminal List<Stmt>        program_stmts;
non terminal List<Stmt>        required_stmts;
non terminal List<Stmt>        optional_func_body_stmts;
non terminal List<TypedVar>    func_params;
non terminal List<TypedVar>    optional_typed_vars;
non terminal Declaration       func_body_declaration;
non terminal Declaration       program_declaration;
non terminal Declaration       class_body_definition;
non terminal TypeAnnotation    return_type;

non terminal AssignStmt        targets_assign;

non terminal IfStmt            elif_stmt, elif_nested, elif_else;


/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */

precedence right IF, ELSE;
precedence left OR;
precedence left AND;
//precedence right IDENTIFIER;
precedence nonassoc NOT;
precedence nonassoc EQUALS, NOT_EQUALS, LESS_THAN, GREATER_THAN, LESS_OR_EQUAL_THAN, GREATER_OR_EQUAL_THAN, IS;
precedence left PLUS, MINUS;
precedence left TIMES, INTEGER_DIVISION, MOD;
//precedence nonassoc UNARY_MINUS;
precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET;
precedence nonassoc LEFT_PARENTHESIS;
precedence right ASSIGN;

/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/


/* program e auxiliares */

program ::= optional_program_declarations:opd program_stmts:ps
            {: RESULT = new Program(opd.isEmpty() ? getLeft(ps) : getLeft(opd),
                                    psxright, opd, ps, errors);
            :}
        |  optional_program_declarations:opd {: RESULT = new Program(opdxleft,
                                    opdxright, opd, empty(), errors);
            :}
        ;

optional_program_declarations ::= optional_program_declarations:opd program_declaration:pd  {: RESULT = combine(opd, pd); :}
                               |                                                            {: RESULT = empty(); :}
                               ;

program_declaration ::= var_def:vd                               {: RESULT = vd; :}
                    | func_def:fd                                {: RESULT = fd; :}
                    | class_def:cd                               {: RESULT = cd; :}
                    ;

program_stmts ::= program_stmts:ps stmt:s                          {: RESULT = combine(ps, s); :}
                       | stmt:s                                     {: RESULT = single(s); :}
                       ;



/* class_def e não terminais auxiliares */

class_def ::= CLASS:c IDENTIFIER:n LEFT_PARENTHESIS IDENTIFIER:sc RIGHT_PARENTHESIS COLON NEWLINE INDENT class_body:cb DEDENT:d 
                {: 
                    Identifier name = new Identifier(nxleft, nxright, n);
                    Identifier superClass = new Identifier(scxleft, scxright, sc);
                    RESULT = new ClassDef(cxleft, cbxright, name, superClass, cb);
                :}
            ;

class_body ::= PASS NEWLINE                                                          {: RESULT = empty(); :}
            |  required_class_body_definitions:rcbd                                  {: RESULT = rcbd; :}
            ;

required_class_body_definitions ::= required_class_body_definitions:rcbd class_body_definition:cbd {: RESULT = combine(rcbd, cbd); :}
                                | class_body_definition:cbd                                        {: RESULT = single(cbd); :}
                                ;

class_body_definition ::= var_def:vd                                 {: RESULT = vd; :}
                       | func_def:fd                                 {: RESULT = fd; :}
                       ;
       
/* func_def e não terminais auxiliares */

func_def ::= DEF:d IDENTIFIER:i LEFT_PARENTHESIS func_params:fp RIGHT_PARENTHESIS return_type:rt COLON:c NEWLINE INDENT optional_func_body_declarations:decls required_stmts:stmts DEDENT
                {: 
                    Identifier id = new Identifier(ixleft, ixright, i);

                    if(rt == null) {
                        rt = new ClassType(cxleft, cxright, "<None>");
                    }

                    RESULT = new FuncDef(dxleft, stmtsxright, id, fp, rt, decls, stmts);
                :}
           ;

func_params ::= optional_typed_vars:t_vars   {: RESULT = t_vars; :}
              |                              {: RESULT = empty(); :}
              ;

optional_typed_vars ::= typed_var:t                         {: RESULT = single(t); :}
                    | optional_typed_vars:t_var COMMA typed_var:t {: RESULT = combine(t_var, t); :}
                    ;


return_type ::= RIGHT_ARROW type:t                                 {: RESULT = t; :}
            |                                                      {: RESULT = null; :}
            ;

optional_func_body_declarations ::= optional_func_body_declarations:ofbd func_body_declaration:fbd  {: RESULT = combine(ofbd, fbd); :}
                 |                                                                                  {: RESULT = empty(); :}
                 ;

func_body_declaration ::= global_decl:gd             {: RESULT = gd; :}
                 | nonlocal_decl:nd                  {: RESULT = nd; :}
                 | var_def:vd                        {: RESULT = vd; :}
                 | func_def:fd                       {: RESULT = fd; :}
                 ;

required_stmts ::= required_stmts:rfbs stmt:s                           {: RESULT = combine(rfbs, s);  :}
                | stmt:s                                                {: RESULT = single(s); :} 
                ;

global_decl ::= GLOBAL:global IDENTIFIER:id_label NEWLINE {: 
                                                        Identifier id = new Identifier(id_labelxleft, id_labelxright, id_label);
                                                        RESULT = new GlobalDecl(globalxleft, id_labelxright, id); 
                                                    :};

nonlocal_decl ::= NONLOCAL:nonlocal IDENTIFIER:id_label NEWLINE {: 
                                                        Identifier id = new Identifier(id_labelxleft, id_labelxright, id_label);
                                                        RESULT = new NonLocalDecl(nonlocalxleft, id_labelxright, id); 
                                                    :};

var_def ::= typed_var:t_var ASSIGN:assign literal:value NEWLINE:n {: 
                                                                RESULT = new VarDef(t_varxleft, valuexright, t_var, value);
                                                            :};

typed_var ::= IDENTIFIER:id COLON type:t {:
                                        Identifier cId = new Identifier(idxleft, idxright, id);
                                        RESULT = new TypedVar(idxleft, txright, cId, t);
                                    :};

type ::= IDENTIFIER:id                                              {: RESULT = new ClassType(idxleft, idxright, id); :} 
        | IDSTRING:idstr                                            {: RESULT = new ClassType(idstrxleft, idstrxright, idstr); :}
        | LEFT_BRACKET:l_bracket type:t RIGHT_BRACKET:r_bracket     {: RESULT = new ListType(l_bracketxleft, r_bracketxright, t); :} ;            

stmt ::= simple_stmt:s_stmt NEWLINE                                     {: RESULT = s_stmt; :}
        | WHILE:w expr:cond COLON block:stmts                           {: RESULT = new WhileStmt(wxleft, stmtsxright, cond, stmts); :}
        | FOR:f IDENTIFIER:id_token IN expr:iterable COLON block:body   {: 
                                                                Identifier id = new Identifier(id_tokenxleft, id_tokenxright, id_token);
                                                                RESULT = new ForStmt(fxleft, bodyxright, id, iterable, body); 
                                                            :}
        | IF:if_token expr:condition COLON block:body       {: RESULT = new IfStmt(if_tokenxleft, bodyxright, condition, body, empty()); :}
        | IF:if_token expr:condition COLON block:ifBody ELSE COLON block:elseBody {: 
                                                RESULT = new IfStmt(if_tokenxleft, elseBodyxright, condition, ifBody, elseBody); 
                                            :}
        | IF:if_token expr:condition COLON block:body elif_nested:el_nested {: 
                                                    RESULT = new IfStmt(if_tokenxleft, el_nestedxright, condition, body, single(el_nested)); 
                                                :}
        | IF:if_token expr:condition COLON block:body elif_else:el_else {: 
                                                    RESULT = new IfStmt(if_tokenxleft, el_elsexright, condition, body, single(el_else)); 
                                                :};

elif_else ::= elif_nested:el_nested ELSE COLON block:elseBody {: RESULT = insertElse(el_nested, elseBody); :};

elif_nested ::= elif_stmt:el  {: RESULT = el; :}
            | elif_stmt:el elif_nested:el_nested {: RESULT = new IfStmt(elxleft, el_nestedxright, el.condition, el.thenBody, single(el_nested)); :};

elif_stmt ::= ELIF:el expr:condition COLON block:body  {: 
                                                        RESULT = new IfStmt(elxleft, bodyxright, condition, body, empty());
                                                     :};

simple_stmt ::= PASS {::}
            | expr:e {: RESULT = new ExprStmt(exleft, exright, e); :}
            | RETURN:ret {: RESULT = new ReturnStmt(retxleft, retxright, null); :}
            | RETURN:ret expr:e {: RESULT = new ReturnStmt(retxleft, retxright, e); :}
            | targets_assign:tgs {: RESULT = tgs; :};

targets_assign ::= target:t ASSIGN expr:e               {: RESULT = new AssignStmt(txleft, exright, single(t), e); :}
            | target:t ASSIGN targets_assign:tgs_assign {: 
                                                            tgs_assign.targets.add(0, t);
                                                            RESULT = tgs_assign;
                                                        :};
 
target ::= IDENTIFIER:id {: RESULT = new Identifier(idxleft, idxright, id); :};

block ::= NEWLINE INDENT program_stmts:s_list DEDENT {: RESULT = s_list; :};

expr ::= cexpr:ce  {: RESULT = ce; :}
       | NOT:not_op expr:e {: RESULT = new UnaryExpr(not_opxleft, exright, not_op, e); :}
       | expr:e1_a AND:and_op expr:e2_a                          {: RESULT = new BinaryExpr(e1_axleft, e2_axright, e1_a, and_op, e2_a); :}
       | expr:e1_o OR:or_op expr:e2_o                            {: RESULT = new BinaryExpr(e1_oxleft, e2_oxright, e1_o, or_op, e2_o); :}
       | expr:e1 IF:if1 expr:e2 ELSE:else1 expr:e3 {: RESULT = new IfExpr(e1xleft, e3xright, e2, e1, e3);:}
       ;


/* A binary expression, illustrating how to find the left and right
 * source position of a phrase. */
cexpr ::=  IDENTIFIER:i {: RESULT =  new Identifier(ixleft, ixright, i);:}
          | literal:n       {: RESULT = n; :}
          | LEFT_BRACKET:lb expr_params:ep RIGHT_BRACKET:rb {: RESULT = new ListExpr(lbxleft, rbxright, ep); :}
          | LEFT_PARENTHESIS:lp expr:e RIGHT_PARENTHESIS:rp {: RESULT = e; :}
          | member_expr:me {: RESULT = me;:}
          | index_expr:ie {: RESULT = ie;:}
          | member_expr:me LEFT_PARENTHESIS:lp expr_params:ep RIGHT_PARENTHESIS:rp {: RESULT = new MethodCallExpr(mexleft, rpxright, me, ep); :}
          | IDENTIFIER:id LEFT_PARENTHESIS:lp expr_params:ep RIGHT_PARENTHESIS:rp          {: 
                                                                                            Identifier identifier = new Identifier(idxleft, idxright, id);
                                                                                            RESULT = new CallExpr(idxleft, rpxright, identifier, ep); 
                                                                                        :}
          | cexpr:e1 bin_op:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
          | MINUS:minus cexpr:c_e {: RESULT = new UnaryExpr(minusxleft, c_exright, minus, c_e);:}
              ;

expr_params ::= optional_exprs:oe                   {: RESULT = oe; :}
              |                                     {: RESULT = empty(); :}
              ;


optional_exprs ::= expr:e                           {: RESULT = single(e); :}
            | optional_exprs:oe COMMA expr:e        {: RESULT = combine(oe, e); :}
            ;



member_expr ::= cexpr:c_ex DOT:dot IDENTIFIER:i {: 
                                                    Identifier identifier = new Identifier(ixleft, ixright, i);
                                                    RESULT =  new MemberExpr(c_exxleft, ixright, c_ex, identifier);
                                                :}
              ;

index_expr ::=  cexpr:c LEFT_BRACKET:lb expr:e RIGHT_BRACKET:rb {: RESULT = new IndexExpr(cxleft, rbxright, c, e);:}
              ;

literal ::= NONE:n {: RESULT = new NoneLiteral(nxleft, nxright);:}
        | TRUE:t {: RESULT = new BooleanLiteral(txleft, txright, true);:}
        | FALSE:f {:  RESULT = new BooleanLiteral(fxleft, fxright, false);:}
        | INTEGER_LITERAL:i {: RESULT = new IntegerLiteral(ixleft, ixright, i); :}
        | IDSTRING:is {:  RESULT = new StringLiteral(isxleft, isxright, is); :}
        | STRING:s {:  RESULT = new StringLiteral(sxleft, sxright, s); :}
        ;

/* binary operators */
bin_op ::= PLUS:plus {:RESULT = plus;:}
         | MINUS:minus {:RESULT = minus;:}
         | TIMES:times {:RESULT = times;:}
         | INTEGER_DIVISION:i_d {:RESULT = i_d;:}
         | MOD:mod {:RESULT = mod;:}
         | LESS_THAN:l_t {:RESULT = l_t;:}
         | GREATER_THAN:g_t {:RESULT = g_t;:}
         | LESS_OR_EQUAL_THAN:l_e_t {:RESULT = l_e_t;:}
         | GREATER_OR_EQUAL_THAN:g_e_t {:RESULT = g_e_t;:}
         | EQUALS:equals {:RESULT = equals;:}
         | NOT_EQUALS:n_equals {:RESULT = n_equals;:}
         | IS:is {:RESULT = is;:}
         ;
